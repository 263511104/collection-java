# 多线程

## 线程

线程是操作系统能够进行运算调度的最小单位，它被包含在进程当中，是进程的实际运作单位

进程是程序的基本执行实体，在任务管理器中每一个程序都有一个对应的进程

简单理解，应用软件中相互独立，可以同时运作的功能

想360中就有木马查杀，电脑清理，系统修复，这样三个线程

## 为什么要有多线程

一个人在流水线工作，十分钟流水线来一个快递，那么就有九分钟会被浪费

我们写代码也一样，以前我们写的代码都是单线程代码，cpu每执行一个语法，就要等它执行完才能到下一步，有了多线程我们就可以在执行这个任务的时候同时进行下一步操作

多线程在我们生活中十分常见，原神的加载页面就可能同时有资源加载线程，动画动态化线程，核对版本信息线程等等等

总之多线程可以大大节省我们程序运行的时间

## 并发和并行

并发就是在同一时刻有多个指令在单个CPU上***交替***执行

重点强调交替，比如我要要打游戏一死就要吃东西等复活，这样就是交替执行充分利用时间，就像一个多路开关在电路中不断换线路

并行就是在同一时刻有多个指令在多个CPU上***同时***执行

并行就和并联一样，两个开关连两条电路

如果我有四个线程，如果总线程数小于四个，这个时候就是并行，但是如果总需要线程数越来越多，那就会转换成并发不断交替，随机切换，在我们计算机中并发和并行是可以同时发生的

## 本地方法

在Java中，`native`是一个修饰符，用于标识一个方法是由本地代码（非Java代码）实现的。当一个方法被声明为`native`时，它的实现并不在Java源代码中，而是通过其他编程语言（如C或C++）编写的本地代码来实现。

使用`native`修饰符的方法被称为本地方法（Native Method）。本地方法的实现通常是使用本地编程语言编写的，因此可以直接调用底层操作系统或其他外部库的功能。这在需要与底层系统进行交互或执行一些性能关键的操作时非常有用。

本地方法的声明在Java中只是一个接口，它的实现通常在本地库中。在Java程序中，可以通过Java Native Interface（JNI）来调用本地方法。JNI提供了一组用于在Java代码和本地代码之间进行交互的接口。

需要注意的是，使用`native`修饰符的方法是Java中与平台相关的部分，因为它们依赖于本地代码的实现。因此，使用本地方法需要谨慎，并且需要确保本地代码的正确性和安全性。

以下是一个使用`native`修饰符的示例：
```java
public class NativeExample {
    public native void nativeMethod();

    public static void main(String[] args) {
        NativeExample example = new NativeExample();
        example.nativeMethod(); // 调用本地方法
    }

    static {
        System.loadLibrary("nativeLibrary"); // 加载本地库
    }
}
```

在上述示例中，`nativeMethod`方法被声明为本地方法，并在`main`方法中调用。在静态代码块中使用`System.loadLibrary`方法加载了一个名为`nativeLibrary`的本地库，该库包含了`nativeMethod`方法的实现。

总而言之，`native`修饰符用于标识一个方法是由本地代码实现的，通过Java Native Interface（JNI）可以在Java代码中调用这些本地方法。

## 多线程的实现方式

### 继承Thread类的方式

***可扩展性差，不能再继承其他类***

Thread类表示Java里面的一个线程，如果说我想拥有一条线程的话，那我就需要创建它的对象并开启它，有两种创建线程的方法，第一种是将本类声明为Thread类的子类，该子类应重写Thread类的run方法，run方法中写要执行的代码，接下来就可以分配并启动该子类的实例，也就是说接下来我可以创建子类的对象，再去调用start方法，就可以开启这条线程了，在开启这条线程后它就会自动去找这个子类的run方法，然后执行run方法里面的代码。我们不能直接拿对象调用里面的run方法，如果是这样那只是仅仅调用了一个方法，和我们之前调用一个方法的效果是一模一样的，start才表示开启线程

假设我们两个线程的内容一样或者很多很杂，我分不清这个内容是哪个线程做的，我可以调用这个子类对象的setName方法给它起个名字默认名字是Thread-0和Thread-1，在打印的时候我们可以使用getName加上要打印的内容，这样我们就可以分清哪个线程做了什么，打印后就可以发现我们程序一下执行线程一，一下执行线程二

以下是对start方法的源码分析

start方法是Thread类中的一个方法，用于启动一个线程。下面是start方法的源码解析：

```java
public synchronized void start() {
    if (threadStatus != 0)
        throw new IllegalThreadStateException();
    // 将线程状态设置为RUNNABLE
    group.add(this);
    boolean started = false;
    try {
        // 调用start0方法启动线程
        start0();
        started = true;
    } finally {
        try {
            if (!started) {
                // 如果启动失败，则从线程组中移除该线程
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
            /* do nothing */
        }
    }
}
```

start方法主要做了以下几件事情：

1. 检查线程状态是否为0（NEW）。如果线程状态不为0，则抛出IllegalThreadStateException异常。
2. 将线程添加到线程组中。
3. 调用start0方法启动线程。
4. 如果启动失败，则从线程组中移除该线程。

start0方法是一个本地方法，具体的实现由底层操作系统提供。它负责创建一个新的操作系统线程，并调用线程的run方法来执行线程的任务。

总结起来，start方法的作用是启动一个线程，并在底层创建一个新的操作系统线程来执行线程的任务。

---

不是所有Thread类中的方法都是线程中的方法。Thread类中有一些方法是用于控制线程的行为和状态的，例如start、join、sleep等方法。这些方法可以在其他线程中调用，用于控制目标线程的执行和等待。

另外，Thread类还包含一些静态方法，例如currentThread、yield、interrupt等方法。这些方法可以在任何线程中调用，用于获取当前线程、让出当前线程的执行时间片、中断线程等操作。

除了控制和操作线程的方法，Thread类还包含一些用于管理线程属性和优先级的方法，例如setName、setPriority等方法。这些方法可以在任何线程中调用，用于设置线程的名称、优先级等属性。

总之，Thread类中的方法包括了控制线程、操作线程、管理线程属性和优先级等功能，不仅限于在线程中调用。所以在实际操作的时候还得看看文档来决定

要区分Thread类中的线程内方法和非线程内方法，可以根据方法的功能和用途进行判断。一般来说，线程内方法是用于控制和操作线程的行为和状态的，而非线程内方法则是用于管理线程属性和优先级的。

以下是一些常见的线程内方法和非线程内方法的示例：

线程内方法：
- start(): 启动一个线程。
- join(): 等待线程执行完成。
- sleep(): 使当前线程暂停一段时间。
- interrupt(): 中断线程的执行。
- yield(): 让出当前线程的执行时间片。

非线程内方法：
- setName(String name): 设置线程的名称。
- getName(): 获取线程的名称。
- setPriority(int priority): 设置线程的优先级。
- getPriority(): 获取线程的优先级。
- currentThread(): 获取当前线程的引用。

需要注意的是，并非所有非线程内方法都不能在线程中调用，只是它们的主要功能是用于管理线程属性和优先级。在实际使用中，可以根据方法的用途和功能来判断是否适合在线程中调用。

### 实现Runnable接口的方式

***扩展性强但编程相对复杂，不能直接使用Thread类中的方法***

多线程的第二种实现方式声明实现Runnable接口的类，然后这个类重写里面的run方法就可以了，在测试类里面要先创建一个自己的类，然后在去创建一个线程new Thread(对象名)，然后再用这个新的new的对象去调用start方法（***个人理解：我们创建的这个类没有继承Thread只是实现了Thread继承的接口，仅仅只是可以重写这个run方法用于start，但是start这个方法是在thread类里面的，我们想要启动这个线程这个方法就必不可少，所以Java定义了一个Thread的有参构造，构造器的形参十有八九是这个Runnable接口，果然是这样，我们传入这个形参（Runnable target）后，会修改Thread类中的target变量为我们传入的形参MyThread，而Thread类中的run方法内实际调用的是target.run，这个时候我们运行start方法就会把target，也就是我们传入的MyThread中的run在线程中执行***）为了分清哪个线程是哪个，我们还需要给线程起个名字，我们这次起名字调用的是Thread里面的setName方法，都一样的，上一种方式继承了Thread类才有的这个方法，都一样可以设置，但是这个地方有问题了，我们在MyThread内不能调用getName方法来写在run方法中作为输出的内容，因为这个时候我的MyThread都没继承Thread，（Runnable只有一个run方法getName方法是在Thread中的），自然就没有getName方法，在这里有一种方法解决，在打印之前，我先获取当前线程的对象不就o了吗，理论成立实践想想怎么做，这里会出现一个大问题，我们使用的进程对象是在测试类中的，无法调用这个对象在MyThread中使用，虽然根据顺序结构，run方法在后面执行，但是我们不能在MyThread中调用我们在test中创建的对象，这个时候就出现了一个返回值是Thread类的静态方法currentThread来帮我们获取当前线程，这个方法被native修饰，是一个本地方法，不在源码中展示，现在我们就可以使用这个对象来调用getName方法结果是一样的，但是这样写总归有点麻烦，所以我直接Thread.currentThread().getName,可以节省写代码的时间，这个就叫做链式编程

### 利用Callable接口和Future接口的方式

我们会发现，前面两种方法，不能获取到run方法的结果，因为重写的它没有返回值，那怎么办呢，这时候我们就需要第三种方法

特点，可以获取到多线程的结果书写的时候麻烦一些

创建一个MyThread实现Callable接口<泛型中写run方法返回的结果>，重写里面的call方法（是有返回值的，表示多线程运行的结果，最后在测试类里创建MyCallable的对象，创建Future用于管理多线程的结果（获取，设置等等等），但是这个Future是一个接口，我们要创建它实现类FutureTask的对象<泛型表示run方法返回的结果>使用了有参构造（参数是Callable c）等等去看看它干了什么，最后再创建Thread对象（好家伙出现了，Thread里的有参构造传入了（FutureTask f）这一步很关键，FutureTask可能实现了Runnable接口），并启动，使用创建的FutureTest类的get方法获取这个返回值，最后输出

逻辑原理

创建Future Task的对象时使用了有参构造，使这个对象的callable变量变为传进来的callable,使state变为new，再创建Thread对象时使用了有参构造，传入了FutureTask，使用了里面的run方法。这时候很明显FutureTask里面的run方法至关重要，run方法先是判断state是不是new，然后给这个线程设置为runner（只有在它原本没有名字的情况下才能设置，并返回true）只有这两点同时成立才不会报错，run方法创建了一个与继承了Callable类的MyThread2的call方法返回值类型相同的一个变量result，并使其等于call方法的返回值，同时进行call方法的使用，和一个判断boolean run变量，一旦正常运作，run会被赋值为true，如果在给result赋值时出现了Throwable ex的异常，就会使ran变为false，result变为null，并设置outcome为这个异常（再使用get方法就会得到这个异常），最后如果run是true就会设置这个result为outcome这个可以通过get来获取的数，然后，会重新读取任务的状态。如果状态大于等于`INTERRUPTING`，表示任务可能被取消，会调用`handlePossibleCancellationInterrupt`方法处理任务的取消操作。最后还会清除runner将其设置为null最后和之前一样用Thread的有参构造调用FutrueTask的run方法，再用FutureTask的对象调用get方法获取这个最终的result，所以实际上这个run方法还是没有返回值的，只是它获取了call方法的返回值并设置成了一个outcome参数来被获取

outcome还有一步转换为result方法的返回值，result方法内部还会判断一遍这个目前的状态是否异常来选择正常返回outcome，或者抛出异常，get方法最终返回这个result方法的返回值

## Thread中常见的成员方法

1. String getName返回此线程的名字，空参构造给线程设置了默认名字
2. void setName(string name)设置线程的名字，除了这个方法，Thread的构造方法也是可以给他设置名字的，有一个带String name的构造方法，但是这些构造都是父类的构造，它的子类如果没有使用super关键字获取是不能使用的（构造方法不能继承）
3. static Thread currentThread()获取当前线程的对象，如果我们不创建线程就会获取main线程
4. static void sleep(long time)让线程休息指定的时间，单位为毫秒，哪条线程执行到这个方法，那么哪条线程就会在这里停留对应的时间，当时间到了之后，线程会自动醒来，继续执行下面的其他代码，有异常直接抛出，睡眠可以让程序更加有序
---
5. setPriority(int newPriority)设置线程的优先级

6. final int getPriority()获取线程的优先级

   优先级最小是1，最大是10，默认是5，优先级越大，抢占到cpu的概率越高
---

7. final void setDaemon(boolean on)设置为守护线程，备胎线程，当其他线程结束了守护线程就会陆续结束，女神线程结束了，备胎线程也就没有存在的必要了，就会慢慢消亡，比如我循环了一百次，女神线程结束后，它可能不到一百次就凉了

   应用场景，比如两个人用qq聊天，左边的人给右边的人发了一个文件，聊天和发送软件可以看作两个线程，现在把聊天窗口关闭了，传输文件就没有执行的必要了，这个时候就可以把线程2设置成守护线程，，就是退出这个页面就不下载了烦死了
---
8. public static void yield()出让线程/礼让线程

9. public void join()插入线程/插入线程

线程太随机执行了，不太好，那我能不能让线程的执行尽可能均匀一点呢，yield表示出让当前线程的执行权，表示当女神线程打印完后，它就会出让当前的cpu执行权，下一次女神和备胎就会重新再去抢夺cpu的执行权，这样就可以实现让线程尽量均匀，它只能尽可能均匀一点，不是绝对的，用的很少

因为非常喜欢女神，我想先看看女神可不可以追到再考虑备胎，这时候我就像女神线程先打印，有没有办法呢，这个时候就可以用到join，表示把调用它的线程插入到当前线程之前，当前线程肯定是main，因为是main调用它，这件事情肯定是main做的，当然也可以让其他线程调用它，这样就可以实现有序的输出，这里有一个细节join必须要在start方法后执行才有用，因为线程要启动才有线程，没启动没线程自然无法插入

## 线程的生命周期

创建线程对象的时候是新建状态，调用start方法运行线程后变成就绪状态，开始抢夺cpu的执行权，这个时候是正在抢还没抢到，还没法执行代码，只有执行资格没有执行权，抢到cpu执行权后就会变成运行状态执行代码，一旦它的执行权被其他线程抢走，就又会回到就绪状态，如果当前线程run执行完了就会变成死亡状态变成垃圾，如果线程遇到了sleep方法，线程就会被阻塞，就没有执行资格，也没有执行权，睡眠时间到了的时候就会回到就绪状态

## 线程的安全问题

多线程在提高效率的同时会有一个弊端，不安全

我们在售出100张票的例子中会发现，同一张票会被多个线程多次销售，要解决这个问题，只需要在变量前加上static，表示所有对象共享这个数据，就可以了，改完还有问题，虽然输出了一百次，但是输出会有重复，还会有超出范围的，要解决这个问题就需要用到下面的知识

### 同步代码块

当多个线程操作同一个数据的时候会出现问题

1. 相同的票出现了多次
2. 出现了超出范围的票

假设线程1先走，走到if内部后休息十毫米，失去了执行权，这时候ticket还没有加，二线程开启后又进来了，ticket还没有加，三线程又满足条件又进来了，等最后ticket一起加的时候为时已晚，就会超出范围，现在线程一先进行了ticket++的操作，还没来得及打印，执行权就被线程2抢走了，ticket再++，就会造成两次打印出现同一张票的情况，重复的次数少只是因为几率比较小，如果我能把操作系统的一整块数据锁起来，只要我执行里面的代码，就算休眠，别的人也得在外面等着，是不是就可以了呢？虽然这样做会降低性能，但是这是必要的，起码在处理多个数据时可以让性能提升很多

此时会用到一个关键字synchronized(锁对象){操作共享数据的代码}

在书写的时候有两个小细节，锁默认打开，有一个线程进去了，锁自动关闭，里面的代码全部执行完毕，线程出来锁自动打开

锁对象很任意，任意到什么程度甚至连object都可以，但是这个锁对象一定要是唯一的，要在这个对象里加一个静态关键字

这种处理方式就叫做同步代码块

#### 两个小细节

第一个细节synchronized代码块不能写在循环的外面，一旦写外面，就会窗口一直接把一百张票卖完，那就和顺序结构区别不大了

synchronized后面的锁对象一定要是唯一的，如果不是唯一的会怎么样呢

如果锁不是唯一的，两条线程看的是不同的锁，那锁就没有意义了，所以要加上static，不加在创建对象的时候，就会创建不同的锁地址，一般会在锁上写当前类的字节码文件对象类名.class其实就是那个class对象，这个对象是唯一的，因为在一个文件夹里面只能有一个MyThread.class文件（地址）

### 同步方法

如果我们想把一个线程方法里的所有代码全都锁起来，就没有必要去用同步代码块了，我可以直接把synchronized关键字加到方法上，把它写在修饰符的后面就可以了泛型会在它还后面，同步方法有两个小特点

1. 同步方法是锁住方法里的所有代码
2. 锁对象不能自己指定，是Java已经规定好的，非静态是this当前方法的调用者也就是我们再test里创建的mt对象是唯一的，锁对象也就是唯一的，如果是静态方法，是当前类的字节码文件作为对象

现在我用第二种创建线程的方式来做同一道题，这个时候ticket不需要变为静态了，因为第二种方式继承了Runnable对象的类，这个对象只需要被创建一次就可以被Thread的有参构造多次使用，所以就没有必要再加ticket了，Ctrl+Alt+M快速改代码为方法，再加一个锁就可以了，感觉这里有点坑啊，如果用的是第一种方法那锁对象就不唯一了，要改为静态方法，这样一来就不可以在一个方法中又修改实例变量，又修改静态变量了，Java这么做肯定有它的道理，但是目前不知道为什么，

对于我们之前学习的，StringBuider，StringBuilder的实例用于多个线程是不安全的，如果需要这样的同步，建议使用StringBuffer

在StringBuffer里的每一个方法都有锁，所以它是线程安全的，以后我们该怎么去选择呢，如果我们的代码是单线程的，使用StringBuilder，如果是多线程环境下，就使用右边的StringBuffer

### Lock锁

虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们看不到在哪里加了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock

Lock的实现比synchronized方法的语句可以获得更广泛的锁定操作，Lock提供了获得锁和释放搜索的方法，这样我们就可以手动的上锁，手动的释放锁

1. void lock():获得锁
2. void unlock():释放锁

Lock是一个接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化，直接用空参构造就ok了，我们在前面上锁，在后面释放锁

但是有个小细节，如果我们使用第一种实现方法来锁，那么就要在锁的对象前加上静态关键字，使所有的对象共享同一把锁防止出错

这个时候新的问题又出现了，程序它没停

解释：线程一进循环后，获得了锁，在休眠时间时，线程2执行，到循环处由于关了门，线程2进不去